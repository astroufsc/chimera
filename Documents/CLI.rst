******************************
Chimera Command Line Interface
******************************

Introduction
============

The original design for Chimera had it fulfill the role of a primarily
*command line based* interface to the Observatory Control System (OCS).
As such, it has a sophisticated, if not a bit complex, API for
implementing *cli* user interfaces to its functionality (unsurprisingly,
there is an almost 1 to 1 relationship between cli commands and
controllers/instruments...).

The goal of this document is to explain how to implement such a cli for
some intended new functionality to be added to Chimera. It will end up
presenting a template for a generic cli.

Chimera scripts
===============

Within an installed Chimera instance, all the clis are located in the
*scripts* subdirectory, which is included in your shell's executable
path.

Each cli has the generic form::

    cli-program (--action-1|--action-2|...|--action-n)
                [--param-1=value1,--param-2=value-2|...|--param-n=value-n

By convention, all the scripts (with the exception of the main entry
point for the system, called **chimera**), should be named
*chimera-[suffix]*, with suffix being as short but descriptive of the
main task as possible. The scripts already defined in the system are:

- :program:`chimera-admin`: contacts the running system, adds instruments/controllers;
- :program:`chimera-cam`: access all tasks related to the instrument camera 
           currently operating (there may be more than one);
- :program:`chimera-console`: *not implemented yet*
- :program:`chimera-dome`: controls all operations for the current dome;
- :program:`chimera-filter`: commands the filter whhel(s) associated with the
           instrument in use;
- :program:`chimera-focus`: manual or automated focusing sequence;
- :program:`chimera-gen-sched`:
- :program:`chimera-gui`: *not implemented yet*
- :program:`chimera-mon`: *not implemented yet*
- :program:`chimera-ppsched`:
- :program:`chimera-pverify`: runs a telescope pointing procedure;
- :program:`chimera-sched`:
- :program:`chimera-taosched`:
- :program:`chimera-tel`: runs telescope based operations.

Running any script with the *--help* option will produce a complete help
screen for your enlightenment. For example:

::

    chimera-filter --help
    Usage: chimera-filter [options]

    Chimera - Observatory Automation System - Filter Wheel Controller

    Options:
      --version             show program's version number and exit
      -h, --help            show this help message and exit
      -v, --verbose         Display information while working
      -q, --quiet           Don't display information while working.
                            [default=True]

      Filter Wheel Information:
        --info              Print Filter Wheel information and exit
        -F, --list-filters  Print available filter names.

      Filter Wheel configuration:
        --wheel=WHEEL       Filter Wheel instrument to be used. If blank, try to
                            guess from chimera.config

      Client Configuration:
        --config=CONFIG     Chimera configuration file to use.
                            default=/home/cdev/.chimera/chimera.config
                            [default=/home/cdev/.chimera/chimera.config]
        -P PORT, --port=PORT
                            Port to which the local Chimera instance will listen
                            to. [default=9002]

      Filter Position:
        -f FILTERNAME, --set-filter=FILTERNAME
                            Set current filter.
        --get-filter        Get the current filter name

      Object Paths:
        -I PATH, --instruments-dir=PATH
                            Append PATH to Wheel load path. This option could be
                            set multiple times to add multiple directories. [de
                            fault=['/path-to installed-chimera/lib/python2.7/
                            site-packages/chimera_python-0.2.dev-py2.7.egg/chimera/
                            instruments']]

This illustrates one of the capabilities of the **API**, described
below, which is to assist in the generation of these help screens. We
will use this cli along this document as an example.

The API
-------

Internally Chimera uses the **optparse** library to handle options,
parameters and values passed on as arguments to the command.

This library is wrapped by a useability layer that automates some
options and eases the definition and construction of a help system for
your cli. Autogenerated options include
``--help --quiet --verbose (default=True) --log=file``

Importing modules
~~~~~~~~~~~~~~~~~

**The following code block is the minimal set that must be included in a
cli:**

.. code:: python

    from chimera.core.cli import ChimeraCLI, action, parameter
    from chimera.core.callback import callback
    from chimera.core.exceptions import ChimeraException
    from chimera.core.compat import freeze_support

Defining your CLI class
~~~~~~~~~~~~~~~~~~~~~~~

The next step is to define your cli's main class. Pay attention to the
naming, it is important to keep it consistent across your code:

.. code:: python

    class ChimeraFilter (ChimeraCLI):
        
        def __init__ (self):
            ChimeraCLI.__init__(self, "chimera-filter", "Filter Wheel Controller", 0.1, port=9002)

Your cli **must** subclass ChimeraCLI, and its constructor is the
latter's one, with the following parameters:

-  "chimera-filter": the **exact** name of your executable script;
-  "Filter Wheel Controller": a short one line description of its
   function;
-  0.1: a version number;
-  port=9002: the port number your chimera instance is listening to
   (more on this later).

Defining your arguments
~~~~~~~~~~~~~~~~~~~~~~~

The next step is to define "help groups". These will put together all
related options help text as defined by your code. In the example cli,
"Filter Wheel Information", "Client Configuration", are help groups:

.. code:: python

            self.addHelpGroup("FILTER", "Filter Wheel configuration")
            self.addInstrument(name="wheel", cls="FilterWheel", required=True,
                               help="Filter Wheel instrument to be used. If blank, try to guess from chimera.config",
                               helpGroup="FILTER")

These two methods (inherited from ChimeraCLI) respectively define the
help group and the options or parameters belonging to it. Their
signature is:

-  addHelpGroup:

   -  "FILTER" is a label (uppercase) identifying the group;
   -  "Filter Wheel configuration" is a short self description.

-  addInstrument:

   -  name="wheel": the instrument to be addressed by this cli;
   -  cls="FilterWheel": the instrument class, as defined in its
      **interface**;
   -  required=True: if this option is present, it requires an argument;
   -  help="Filter Wheel instrument to be used. If blank, try to guess
      from chimera.config":
   -  helpGroup="FILTER": the help group (identified by its label) this
      option is placed under.

There is a corresponding *addController()* method for scripts that
interact with controllers; an example currently included is the
*chimera-pverify* script, which in its source includes:

.. code:: python

            self.addController(name="pverify", cls="PointVerify", required=True, helpGroup="PVERIFY", help="Pointing verification controller to be used")

There is also an *addParameters()* method, which allows passing of
param=value pairs as needed by some other specified *action*. For
example, the *chimera-tel* script has a ``--slew`` action, which would
require a target in the form of coordinates:

::

    chimera-tel --slew --ra=val --dec=val --epoch=val

The coding for this (from chimera-tel) is:

.. code:: python

            self.addParameters(dict(name="ra", type="string", helpGroup="COORDS", help="Right Ascension."),
                               dict(name="dec", type="string", helpGroup="COORDS", help="Declination."),
                               dict(name="epoch", type="string", default="J2000", helpGroup="COORDS", help="Epoch"),
                               dict(name="az", type="string", helpGroup="COORDS", help="Local Azimuth."),
                               dict(name="alt", type="string", helpGroup="COORDS", help="Local Altitude."),
                               dict(name="objectName", long="object", type="string", helpGroup="COORDS", help="Object name"),)

Doing stuff
~~~~~~~~~~~

The last step is to actually attach some functionality to all those neat
options. You noticed in the module imports section, along with the cli
superclass we also imported a couple of items: *action*, and
*parameter*. In python lingo, these are known as **decorators**, and
will help us attach chimera functionality to our script.

In our filter script example, here is an example of a function that
changes the filter wheel position, decorated as an action to integrate
it in the CLI machinery;

.. code:: python

        @action(name="filtername", short="f", long="--set-filter", type="str", help="Set current filter.",
                actionGroup="FILTER_CHANGE", helpGroup="FILTER_CHANGE")
        def changeFilter(self, options):

            if self.options.filtername and filter not in self.wheel.getFilters():
                self.err("Invalid filter '%s'" % self.options.filtername)
                self.exit()

            self.out("Changing current filter to %s ..." % self.options.filtername, end="")
            try:
                self.wheel.setFilter(self.options.filtername)
                self.out("OK")
            except InvalidFilterPositionException:
                self.err("ERROR (Invalid Filter)")

The *chimera-focus* script so far contains the only example of the use
of the **@parameter** decorator, as an alternative to the
*addParameter()* method; in fact both are used in there.

.. code:: python

        @parameter(long="range", helpGroup="AUTOFOCUS", default="1000-6000",
                   help="Defines autofocus focuser range to be covered. Use start-end, "
                   "as in 1000-6000 to run from 1000 to 6000.", metavar="START-END")
        def autofocus_range(self, value):
            r = re.compile("(?P<start>\d+)-(?P<end>\d+)")
            m = r.match(value)
            if not m:
                raise ValueError("Invalid start-end range")

            start, end = m.groups()
            start = int(start)
            end = int(end)
            return (start, end)

The last step
-------------

The only remaining task is to give your python code the attributes of an
executable command line script:

.. code:: python

    def main():
        cli = ChimeraFilter()
        cli.run(sys.argv)
        cli.wait()
        
    if __name__ == '__main__':

        main()

A CLI script template
---------------------

Lets collect all this document's tips into a workable template for a
command line interface to Chimera. Comments wil be interspersed for
guidance.

.. code:: python

    # Modules need importing;
    # First the foundation stones
    from chimera.core.cli import ChimeraCLI, action, parameter
    # You probably need this one to access resources from the running chimera
    from chimera.core.callback import callback
    # There are more exceptions you can import depending on the context
    from chimera.core.exceptions import ChimeraException
    # Windows compatibility
    from chimera.core.compat import freeze_support


    class ChimeraTemplate (ChimeraCLI):

        def __init__ (self):
            # Constructor
            ChimeraCLI.__init__(self, "chimera-template", "Generate a Chimera Template", 0.1, port=9050)

            # Start adding help groups; repeat as needed
            self.addHelpGroup("LABEL", "Template  configuration")
            
            # If your script talks to an instrument, you need to specify it
            self.addInstrument(name="replacer", cls="TemplateReplacer", required=True,
                               help="Template language to use; if blank, try to guess from chimera.config",
                               helpGroup="LABEL")
                               
            # ...and/or if you need to talk to a controller, do this
            self.addController(name="mouthwash", cls="MouthWash", required=True, helpGroup="OTHERLABEL",
            help="Curse words filtering controller to be used")
            
            # Are you old fashioned? Add these (but see further down)
            self.addParameters(dict(name="level", type="string", helpGroup="CENSOR", help="Cursing tolerance."),
                               dict(name="rating", type="string", helpGroup="CENSOR", help="Age rating."),)

            # Add some acting code
            @action(name="sanitize", short="s", long="--sanitize", type="str", help="Black out curse words.",
                    actionGroup="LABEL", helpGroup="LABEL")
            def sanitizeText(self, options):
            # Your code here!
            
            # Are you trendy? Do this instead to define parameters
            @parameter(long="level", helpGroup="CENSOR", default="yes",
                       help="Defines the tolerance level for cursing and generally inadequate language")
            def autofocus_range(self, value):
                r = re.compile("(?P<start>\d+)-(?P<end>\d+)")
                m = r.match(value)
                    if not m:
                        raise ValueError("Invalid start-end range")

                    start, end = m.groups()
                    start = int(start)
                    end = int(end)
                    return (start, end)

