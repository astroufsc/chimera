#! /usr/bin/env python
# -*- coding: iso-8859-1 -*-

# chimera - observatory automation system
# Copyright (C) 2006-2009  P. Henrique Silva <henrique@astro.ufsc.br>

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.
import string
import re
import sys
import os
import shutil
import time
import yaml
from chimera.core.cli import ChimeraCLI, action
from chimera.core.constants import DEFAULT_PROGRAM_DATABASE
from chimera.core.callback import callback
from chimera.util.position import Position
from chimera.util.output import blue, green, red
from chimera.controllers.scheduler.status import SchedulerStatus
from chimera.controllers.scheduler.states import State
from chimera.controllers.scheduler.model import (Session, Program, AutoFocus,
                                                 PointVerify, Point,
                                                 Expose)

actionDict = {'autofocus': AutoFocus,
              'pointverify': PointVerify,
              'point': Point,
              'expose': Expose,
              }


class ChimeraSched(ChimeraCLI):
    def __init__(self):
        ChimeraCLI.__init__(
            self, "chimera-sched", "Scheduler controller", 0.1, port=9010)

        self.addHelpGroup("SCHEDULER", "Scheduler")
        self.addController(name="scheduler",
                           cls="Scheduler",
                           required=True,
                           help="Scheduler controller to be used",
                           helpGroup="SCHEDULER")

        databaseHelp = """Database options.

        The quickest and less configurable way to configure the scheduler database is to use
        a file with the following format:

        # RA      dec       epoch  type    name  N*(f1:t1:n1, f2:t2:n2, ......)
        14:00:00 -30:00:00  J2000  OBJECT  obj1  2*(V:7, R:6:2, B:5:2)
        15:00:00 -30:00:00  NOW    OBJECT  obj2  2*(V:7, R:6:2, B:5:2)

        # special targets follow different format
        # for bias and dark, filter is ignored, we use same format just to keep it simple

        # type name       N[*(f1:t1:n1, ...)]
        FLAT   flat       3*(V:10:1, R:8:2, B:9:3)
        BIAS   bias       1*(V:0)
        DARK   dark       1*(V:1:4)
        OBJECT \"NGC 5272\" 1*(B:10:10)

        It is also possible to use a ".yaml" file with the database configuration for each program. The file
        must have a .yaml extension so the script knows how to parse it.

        programs:
            # You can configure each database to its fullest.

            -   program:
                name: PRG01           # (optional)
                pi: Tiago Ribeiro     # (optional)
                priority: 1           # (optional)
                slewAt: 57500.030     # Add time to slew in MJD (optional)
                exposeAt: 57500.040   # Add time to expose in MJD (optional)

                # Add actions in the order they are intended to be performed.
                actions:
                    -   action: point
                        ra: 14:00:00
                        dec: -30:00:00
                        epoch: J2000

                    -   action: autofocus
                        start: 100
                        end: 200
                        step: 10
                        filter: R
                        exptime: 10

                    -   action: pointverify
                        here: True

                    -   action: expose
                        filter: V
                        frames: 1
                        exptime: 7
                        imageType: OBJECT
                        objectName: obj1 acq

                    -   action: expose
                        filter: R
                        frames: 2
                        exptime: 6
                        imageType: OBJECT
                        objectName: obj1 acq

                    -   action: expose
                        filter: B
                        frames: 2
                        exptime: 5
                        imageType: OBJECT
                        objectName: obj1 acq

            # new target with no autofocus or pointverify
            -   program:
                name: PRG02
                pi: William Schoenell
                priority: 2
                actions:
                    -   action: point
                        ra: 15:00:00
                        dec: -30:00:00
                        epoch: NOW

                    -   action: expose
                        filter: V
                        frames: 1
                        exptime: 7
                        imageType: OBJECT
                        objectName: obj1 acq

                    -   action: expose
                        filter: R
                        frames: 2
                        exptime: 6
                        imageType: OBJECT
                        objectName: obj1 acq

                    -   action: expose
                        filter: B
                        frames: 2
                        exptime: 5
                        imageType: OBJECT
                        objectName: obj1 acq

            # Point to a target name
            -   program:
                name: PROG03
                pi: Antonio Kanaan
                priority: 3
                actions:
                    -   action: point
                        name: NGC 5272

                    -   action: expose
                        filter: B
                        frames: 10
                        exptime: 10
                        imageType: OBJECT
                        objectName: NGC 5272

        # calibrations

            -   program:
                name: DAYLIGHT CALIBRATIONS
                pi: Tiago Ribeiro
                actions:
                    # BIAS
                    -   action: expose
                        frames: 10
                        imageType: BIAS  # This will set shutter to close

                    # DARK
                    -   action: expose
                        frames: 10
                        exptime: 100
                        imageType: DARK  # This will set shutter to close already

                    # LIGHT DARK
                    -   action: expose
                        frames: 10
                        exptime: 100
                        shutter: OPEN    # In case you want to take light dark, you can specify shutter to be open
                        imageType: DARK

                    # FLAT FIELD
                    -   action: point
                        alt: 80:00:00
                        az: 10:00:00

                    -   action: expose
                        frames: 10
                        filter: V
                        exptime: 10
                        imageType: FLAT # This will turn flat field lamp on, by default

                    -   action: expose
                        frames: 10
                        filter: R
                        exptime: 8
                        imageType: FLAT # This will turn flat field lamp on, by default

                    -   action: expose
                        frames: 9
                        filter: B
                        exptime: 20
                        imageType: FLAT # This will turn flat field lamp on, by default

        """

        self.addHelpGroup("DB", databaseHelp)
        self.addHelpGroup("RUN", "Start/Stop/Info")

        self.addParameters(dict(name="filename",
                                long="file",
                                short="f",
                                helpGroup="DB",
                                default="",
                                help="Filename of the input database.",
                                metavar="FILENAME"),
                           dict(name="output",
                                short="o",
                                type="string",
                                helpGroup="DB",
                                help="Images base filename including full path if needed.",
                                default="$NAME-$DATE-$TIME"))

    @action(long="new",
            help="Generate a new database from a text file (excluding all programs already in database)",
            helpGroup="DB",
            actionGroup="DB")
    def newDatabase(self, options):

        # save a copy
        if os.path.exists(DEFAULT_PROGRAM_DATABASE):
            shutil.copy(DEFAULT_PROGRAM_DATABASE, "%s.%s.bak" %
                        (DEFAULT_PROGRAM_DATABASE, time.strftime("%Y%m%d%H%M%S")))

        # delete all programs
        session = Session()
        programs = session.query(Program).all()
        for program in programs:
            session.delete(program)
        session.commit()

        self.generateDatabase(options)

    @action(long="append", help="Append programs to database from a text file",
            helpGroup="DB", actionGroup="DB")
    def appendDatabase(self, options):
        self.generateDatabase(options)

    def generateDatabase(self, options):

        if os.path.splitext(options.filename)[-1] == '.yaml':
            self._generateDatabase_yaml(options)
        else:
            self._generateDatabase_basic(options)

    def _generateDatabase_yaml(self, options):

        with open(options.filename, 'r') as stream:
            try:
                prgconfig = yaml.load(stream)
            except yaml.YAMLError as exc:
                self.exit(exc)

        session = Session()

        programs = []

        for prg in prgconfig['programs']:

            # process program

            program = Program()
            for key in prg.keys():
                if hasattr(program, key) and key != 'actions':
                    try:
                        setattr(program, key, prg[key])
                    except:
                        self.err('Could not set attribute %s = %s on Program' % (key, prg[key]))

            self.out("# program: %s" % program.name)

            # process actions
            for actconfig in prg['actions']:
                act = actionDict[actconfig['action']]()
                self.out('Action: %s' % actconfig['action'])

                if actconfig['action'] == 'point':
                    if 'ra' in actconfig.keys() and 'dec' in actconfig.keys():
                        epoch = 'J2000' if 'epoch' not in actconfig.keys() else actconfig['epoch']
                        position = Position.fromRaDec(actconfig['ra'], actconfig['dec'], epoch)
                        self.out('Coords: %s' % position)
                        act.targetRaDec = position
                        # act = Point(targetRaDec=position)
                    elif 'alt' in actconfig.keys() and 'az' in actconfig.keys():
                        position = Position.fromAltAz(actconfig['alt'], actconfig['az'])
                        self.out('Coords: %s' % position)
                        act.targetAltAz = position
                    else:
                        self.out('Target name: %s' % actconfig['name'])
                        act.targetName = actconfig['name']

                else:
                    for key in actconfig.keys():
                        if hasattr(act, key) and key != 'action':
                            self.out('\t%s: %s' % (key, actconfig[key]))
                            try:
                                setattr(act, key, actconfig[key])
                            except:
                                self.err('Could not set attribute %s = %s on action %s' % (key,
                                                                                           actconfig[key],
                                                                                           actconfig['action']))
                program.actions.append(act)

            self.out("")
            programs.append(program)

        self.out("List contain %i programs" % len(programs))
        session.add_all(programs)
        session.commit()

        self.out("Restart the scheduler to run it with the new database.")

    def _generateDatabase_basic(self, options):
        f = None
        try:
            f = open(options.filename, "r")
        except:
            self.exit("Could not find '%s'." % options.filename)

        session = Session()

        lineRe = re.compile(
            '(?P<coord>(?P<ra>[\d:-]+)\s+(?P<dec>\+?[\d:-]+)\s+(?P<epoch>[\dnowNOWJjBb\.]+)\s+)?(?P<imagetype>[\w]+)'
            '\s+(?P<objname>\'([^\\n\'\\\\]|\\\\.)*\'|"([^\\n"\\\\]|\\\\.)*"|([^ \\n"\\\\]|\\\\.)*)\s+(?P<exposures>[\w\d\s:\*\(\),]*)')
        programs = []

        for i, line in enumerate(f):

            if line.startswith("#"):
                continue
            if len(line) == 1:
                continue

            matchs = lineRe.search(line)

            if matchs is None:
                print "Couldn't process line #%d" % i
                continue

            params = matchs.groupdict()

            position = None
            objname = None

            if params.get("coord", None):
                position = Position.fromRaDec(params['ra'], params['dec'], params['epoch'])

            imagetype = params['imagetype'].upper()
            objname = params['objname'].replace("\"", "")

            multiplier, exps = params['exposures'].split("*")
            try:
                multiplier = int(multiplier)
            except ValueError:
                multiplier = 1

            exps = exps.replace("(", "").replace(")", "").strip().split(",")

            for i in range(multiplier):

                program = Program(
                    name="%s-%03d" % (objname.replace(" ", ""), i))

                self.out("# program: %s" % program.name)

                if imagetype == "OBJECT":
                    if position:
                        program.actions.append(Point(targetRaDec=position))
                    else:
                        program.actions.append(Point(targetName=objname))

                if imagetype == "FLAT":
                    site = self._remoteManager.getProxy("/Site/0")
                    flatPosition = Position.fromAltAz(site['flat_alt'], site['flat_az'])
                    program.actions.append(Point(targetAltAz=flatPosition))

                if imagetype == "AUTOFOCUS":
                    if position:
                        program.actions.append(Point(targetRaDec=position))
                    else:
                        program.actions.append(Point(targetName=objname))
                    exp = exps[0]
                    if exp.count(":") > 1:
                        filter, exptime, frames = exp.strip().split(":")
                    else:
                        filter, exptime = exp.strip().split(":")
                        frames = 10
                    program.actions.append(AutoFocus(filter=filter, exptime=exptime, step=multiplier, start=frames))
                    programs.append(program)
                    break

                for exp in exps:
                    if exp.count(":") > 1:
                        filter, exptime, frames = exp.strip().split(":")
                    else:
                        filter, exptime = exp.strip().split(":")
                        frames = 1

                    if imagetype in ("OBJECT", "FLAT"):
                        shutter = "OPEN"
                    else:
                        shutter = "CLOSE"

                    if imagetype == "BIAS":
                        exptime = 0

                    if imagetype in ("BIAS", "DARK"):
                        filter = None

                    self.out("%s %s %s filter=%s exptime=%s frames=%s" % (
                        imagetype, objname, str(position), filter, exptime, frames))

                    program.actions.append(Expose(shutter=shutter,
                                                  filename=string.Template(options.output).safe_substitute(
                                                      {'NAME': objname.replace(" ", "")}),
                                                  filter=filter, frames=frames, exptime=exptime, imageType=imagetype,
                                                  objectName=objname))
                self.out("")
                programs.append(program)
        self.out("List contain %i programs" % len(programs))
        session.add_all(programs)
        session.commit()

        self.out("Restart the scheduler to run it with the new database.")

    @action(help="Start the scheduler", helpGroup="RUN", actionGroup="RUN")
    def start(self, options):
        self.out("=" * 40)
        self.out("Starting ...", end="")
        self.scheduler.start()
        self.out("%s" % green("OK"))
        self.out("=" * 40)
        self.monitor(options)

    @action(help="Stop the scheduler", helpGroup="RUN", actionGroup="RUN")
    def stop(self, options):
        self.scheduler.stop()
        self.out("OK")

    @action(help="Restart the scheduler", helpGroup="RUN", actionGroup="RUN")
    def restart(self, options):
        self.out("=" * 40)
        self.out("Restarting ...", end="")
        self.scheduler.stop()
        self.scheduler.start()
        self.out("%s" % green("OK"))
        self.out("=" * 40)
        self.monitor(options)

    @action(help="Print scheduler information", helpGroup="RUN")
    def info(self, options):
        self.out("=" * 40)
        self.out("Scheduler: %s" % self.scheduler.getLocation())
        self.out("State: %s" % self.scheduler.state())
        if self.scheduler.state() == State.BUSY and self.scheduler.currentAction():
            session = Session()
            action = session.merge(self.scheduler.currentAction())
            program = session.query(Program).filter(
                Program.id == action.program_id).one()
            self.out("Working on: %s (%s)" % (program.name, str(action)))

        self.out("=" * 40)

    @action(help="Monitor scheduler actions", helpGroup="RUN")
    def monitor(self, options):

        @callback(self.localManager)
        def programBeginClbk(program):
            session = Session()
            program = session.merge(program)
            self.out("=" * 40)
            self.out("%s %s" % (blue("[program]"), program.name))

        @callback(self.localManager)
        def programCompleteClbk(program, status, message=None):
            session = Session()
            program = session.merge(program)
            if status == SchedulerStatus.OK:
                self.out("%s %s %s" %
                         (blue("[program]"), program.name, green(str(status))))
            else:
                self.out("%s %s %s (%s)" % (
                    blue("[program]"), program.name, red(str(status)), red(str(message))))

        @callback(self.localManager)
        def actionBeginClbk(action, message):
            session = Session()
            action = session.merge(action)
            self.out("%s %s ..." % (blue("[action] "), message), end="")

        @callback(self.localManager)
        def actionCompleteClbk(action, status, message=None):
            session = Session()
            action = session.merge(action)

            if status == SchedulerStatus.OK:
                self.out("%s" % green(str(status)))
            else:
                self.out("%s (%s)" % (red(str(status)), red(str(message))))

        @callback(self.localManager)
        def stateChangedClbk(newState, oldState):
            if newState == State.OFF:
                self.out("=" * 40)
                self.out("%s finished all programs" % blue("[scheduler]"))
                self.out("=" * 40)
                self.exit()

        self.scheduler.programBegin += programBeginClbk
        self.scheduler.programComplete += programCompleteClbk
        self.scheduler.actionBegin += actionBeginClbk
        self.scheduler.actionComplete += actionCompleteClbk
        self.scheduler.stateChanged += stateChangedClbk

        if self.scheduler.state() == State.OFF:
            self.out("%s no programs to do" % blue("[scheduler]"))
        else:
            self.wait(abort=False)


def main():
    cli = ChimeraSched()
    cli.run(sys.argv)
    cli.wait()


if __name__ == '__main__':
    main()
